// Code generated by sqlc. DO NOT EDIT.
// source: post.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const createPost = `-- name: CreatePost :exec
INSERT INTO posts 
    (url, image, user_name)
VALUES 
    (?, ?, ?)
`

type CreatePostParams struct {
	Url      string `json:"url"`
	Image    string `json:"image"`
	UserName string `json:"user_name"`
}

func (q *Queries) CreatePost(ctx context.Context, arg CreatePostParams) error {
	_, err := q.db.ExecContext(ctx, createPost, arg.Url, arg.Image, arg.UserName)
	return err
}

const deletePost = `-- name: DeletePost :exec
UPDATE posts 
SET deleted_at = NOW() 
WHERE
	id = ?
`

func (q *Queries) DeletePost(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, deletePost, id)
	return err
}

const getPost = `-- name: GetPost :one
SELECT
	id, created_at, updated_at, deleted_at, url, image, score, user_name 
FROM
	posts 
WHERE
	posts.id = ? 
	AND deleted_at IS NULL
`

func (q *Queries) GetPost(ctx context.Context, id int32) (Post, error) {
	row := q.db.QueryRowContext(ctx, getPost, id)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Url,
		&i.Image,
		&i.Score,
		&i.UserName,
	)
	return i, err
}

const getPosts = `-- name: GetPosts :many
SELECT
	id, created_at, updated_at, deleted_at, url, image, score, user_name 
FROM
	posts 
WHERE
	deleted_at IS NULL 
ORDER BY
	id
`

func (q *Queries) GetPosts(ctx context.Context) ([]Post, error) {
	rows, err := q.db.QueryContext(ctx, getPosts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Post{}
	for rows.Next() {
		var i Post
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.Url,
			&i.Image,
			&i.Score,
			&i.UserName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPostsByUser = `-- name: GetPostsByUser :many
SELECT
	id, created_at, updated_at, deleted_at, url, image, score, user_name 
FROM
	posts 
WHERE
	user_name = ? 
	AND deleted_at IS NULL
`

func (q *Queries) GetPostsByUser(ctx context.Context, userName string) ([]Post, error) {
	rows, err := q.db.QueryContext(ctx, getPostsByUser, userName)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Post{}
	for rows.Next() {
		var i Post
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.Url,
			&i.Image,
			&i.Score,
			&i.UserName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getVotedPost = `-- name: GetVotedPost :one
SELECT
	p.id, p.created_at, p.updated_at, p.deleted_at, p.url, p.image, p.score, p.user_name, 
	IFNULL(pv.upvoted, 0) as upvoted 
FROM
	posts p
	LEFT JOIN post_votes AS pv ON pv.post_id = p.id 
	AND pv.user_id = ? 
WHERE
	p.deleted_at IS NULL AND
	p.id = ?
`

type GetVotedPostParams struct {
	UserID int32 `json:"user_id"`
	ID     int32 `json:"id"`
}

type GetVotedPostRow struct {
	ID        int32        `json:"id"`
	CreatedAt time.Time    `json:"created_at"`
	UpdatedAt time.Time    `json:"updated_at"`
	DeletedAt sql.NullTime `json:"deleted_at"`
	Url       string       `json:"url"`
	Image     string       `json:"image"`
	Score     int32        `json:"score"`
	UserName  string       `json:"user_name"`
	Upvoted   interface{}  `json:"upvoted"`
}

func (q *Queries) GetVotedPost(ctx context.Context, arg GetVotedPostParams) (GetVotedPostRow, error) {
	row := q.db.QueryRowContext(ctx, getVotedPost, arg.UserID, arg.ID)
	var i GetVotedPostRow
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Url,
		&i.Image,
		&i.Score,
		&i.UserName,
		&i.Upvoted,
	)
	return i, err
}

const getVotedPosts = `-- name: GetVotedPosts :many
SELECT
	p.id, p.created_at, p.updated_at, p.deleted_at, p.url, p.image, p.score, p.user_name,
	IFNULL(pv.upvoted, 0) as upvoted 
FROM
	posts p
	LEFT JOIN ( SELECT id, created_at, updated_at, deleted_at, upvoted, user_id, post_id FROM post_votes WHERE user_id = ? ) AS pv ON pv.post_id = p.id 
WHERE
	p.deleted_at IS NULL
`

type GetVotedPostsRow struct {
	ID        int32        `json:"id"`
	CreatedAt time.Time    `json:"created_at"`
	UpdatedAt time.Time    `json:"updated_at"`
	DeletedAt sql.NullTime `json:"deleted_at"`
	Url       string       `json:"url"`
	Image     string       `json:"image"`
	Score     int32        `json:"score"`
	UserName  string       `json:"user_name"`
	Upvoted   interface{}  `json:"upvoted"`
}

func (q *Queries) GetVotedPosts(ctx context.Context, userID int32) ([]GetVotedPostsRow, error) {
	rows, err := q.db.QueryContext(ctx, getVotedPosts, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetVotedPostsRow{}
	for rows.Next() {
		var i GetVotedPostsRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.Url,
			&i.Image,
			&i.Score,
			&i.UserName,
			&i.Upvoted,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
